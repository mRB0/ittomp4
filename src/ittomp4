#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division

import sys
import logging
import contextlib
import subprocess
import math
import threading
import struct

#FFMPEG = r'C:\Users\mrb\Documents\Apps\ffmpeg-20141228-git-750b10f-win64-static\bin\ffmpeg'
FFMPEG = 'ffmpeg'

# C:\Users\mrb\Documents\Apps\ffmpeg-20141228-git-750b10f-win64-static\bin\ffmpeg -f rawvideo -pixel_format argb -video_size 1920x1080 -framerate 60 -i video.raw-1920x1080-argb -vsync 2 -crf 15 -vcodec libx264 -pix_fmt yuv420p -preset ultrafast -threads 3 -an -movflags faststart out.mp4

# ffmpeg -y -f s16le -ar 48000 -ac 2 -i out.rawaudio -b:a 256k out.m4a

# -- image writer --

import cairo
import socket
import random

import decode_mod

from sys import platform as _platform
if _platform == 'linux' or _platform == 'linux2':
    import cairofont_freetype as cairofont
elif _platform == 'win32':
    import cairofont_windows as cairofont
elif _platform == 'darwin':
    import cairofont_osx as cairofont

FONT_FACE = cairofont.load_font('Comic Sans MS')

from twisted.internet.protocol import Factory, Protocol
from twisted.internet import reactor
from twisted.internet.interfaces import IPushProducer
from zope.interface import implements

class VideoProducer(object):
    implements(IPushProducer)
    
    FRAMES_DONE = object()

    def __init__(self, write_frame):
        self._pause = False
        self._stop = False

        self._pauseLock = threading.Condition()
        
        self._thread = threading.Thread(target=self._produce_frames, args=(write_frame,))
        self._thread.start()
        
    def resumeProducing(self):
        self._pauseLock.acquire()
        self._pause = False
        self._pauseLock.notify()
        self._pauseLock.release()

    def pauseProducing(self):
        self._pauseLock.acquire()
        self._pause = True
        self._pauseLock.notify()
        self._pauseLock.release()

    def stopProducing(self):
        self._pauseLock.acquire()
        self._pause = True
        self._stop = True
        self._pauseLock.notify()
        self._pauseLock.release()
    
    def _produce_frames(self, write_frame):
        logging.info("Start producing frames")

        try:
            barwidth = 100
            step = 10

            surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1920, 1080)
            ctx = cairo.Context(surface)

            for i in xrange(0, 11 * 60):
                self._pauseLock.acquire()
                try:
                    while self._pause:
                        if self._stop:
                            logging.warning("Stop requested before completion")
                            return

                        logging.debug("Pausing until next frame")
                        self._pauseLock.wait()

                finally:
                    self._pauseLock.release()

                logging.debug("Produce a frame")

                ctx.new_path()
                ctx.rectangle(0, 0, 1920, 1080)
                ctx.set_source_rgb(math.cos(i / 240 * (math.pi * 2)) / 2 + 0.5, 0, math.sin(i / 180 * (math.pi * 2)) / 2 + 0.5)
                ctx.fill()



                horizbar_y_ctr = (1080 / 2) + (int(math.cos(i / 240 * (math.pi * 2)) * (1080 / 2 * .8)))
                max_extent = int(1080 * .08 / 2)

                for h in xrange(max_extent, 0, -1):
                    ctx.new_path()
                    ctx.rectangle(0, horizbar_y_ctr - h, 1920, h * 2)
                    ctx.set_source_rgba(1, 1, 1, (max_extent - h) / pow(max_extent, 2))
                    ctx.fill()



                ctx.new_path()

                if 1920 - ((i * step) % 1920) < barwidth:
                    ctx.rectangle((i * step) % 1920 - 1920, 0, barwidth, 1080)
                ctx.rectangle((i * step) % 1920, 0, barwidth, 1080)

                ctx.set_source_rgb(0.25, 1, 0.25)
                ctx.fill()


                ctx.set_font_face(FONT_FACE)
                ctx.set_font_size(128)
                ctx.set_source_rgb(1, 1, 1)

                for pos, ltr in enumerate('  YOU ARE FULL OF BOMBS AND/OR KEYS'):
                    x = 1920 - i * step + (128 * pos)
                    y = (1080 / 2) - (1080 * 0.2 * math.sin((x + (i * step/4)) * math.pi / 1020))
                    
                    ctx.move_to(x, y)
                    ctx.show_text(ltr)
                
                surface_data = str(surface.get_data())

                reactor.callFromThread(write_frame, surface_data)

            #import pdb; pdb.set_trace()
            logging.info("Done producing frames")
        except:
            logging.exception("ERROR producing frames")
        finally:
            reactor.callFromThread(write_frame, VideoProducer.FRAMES_DONE)

class VideoWriter(Protocol):
    _started = False

    def __init__(self, manager):
        self._manager = manager
        self._active = False
    
    def connectionMade(self):
        if VideoWriter._started:
            logging.warning("Connection made after start")
            self.transport.loseConnection()
            return
        
        self._active = True
        VideoWriter._started = True
            
        self._video_producer = VideoProducer(self._write_frame)
        self.transport.registerProducer(self._video_producer, True)
        self._video_producer.resumeProducing()

    def connectionLost(self, reason):
        if self._active:
            self._manager.notify_done()
        
    def _write_frame(self, frame_data):
        if frame_data is VideoProducer.FRAMES_DONE:
            logging.info("Dropping connection")
            self.transport.unregisterProducer()
            self.transport.loseConnection()
        else:
            self.transport.write(frame_data)
        
        
class VideoWriterFactory(Factory):
    def __init__(self, manager):
        self._manager = manager
        
    def buildProtocol(self, addr):
        return VideoWriter(self._manager)


### Audio ###

class AudioProducer(object):
    implements(IPushProducer)
    
    DONE = object()

    def __init__(self, filename, write_samples):
        self._filename = filename
        
        self._pause = False
        self._stop = False

        self._pauseLock = threading.Condition()
        
        self._thread = threading.Thread(target=self._produce_samples, args=(write_samples,))
        self._thread.start()
        
    def resumeProducing(self):
        self._pauseLock.acquire()
        self._pause = False
        self._pauseLock.notify()
        self._pauseLock.release()

    def pauseProducing(self):
        self._pauseLock.acquire()
        self._pause = True
        self._pauseLock.notify()
        self._pauseLock.release()

    def stopProducing(self):
        self._pauseLock.acquire()
        self._pause = True
        self._stop = True
        self._pauseLock.notify()
        self._pauseLock.release()
    
    def _produce_samples(self, write_samples):
        logging.info("Start decoding audio")

        try:
            with contextlib.closing(decode_mod.Module(self._filename)) as mod:

                while True:
                    self._pauseLock.acquire()
                    try:
                        while self._pause:
                            if self._stop:
                                logging.warning("Stop requested before completion")
                                return

                            logging.debug("Pausing until next buffer")
                            self._pauseLock.wait()

                    finally:
                        self._pauseLock.release()

                    logging.debug("Produce some audio")

                    samples_buffer_raw = mod.decode(4096)
                    if samples_buffer_raw is None:
                        break
                    samples_buffer = ''.join([struct.pack('<h', samp) for samp in samples_buffer_raw])

                    reactor.callFromThread(write_samples, samples_buffer)

                logging.info("Done producing audio")
        except:
            logging.exception("ERROR decoding audio")
        finally:
            reactor.callFromThread(write_samples, AudioProducer.DONE)

class AudioWriter(Protocol):
    _started = False

    def __init__(self, manager):
        self._manager = manager
        self._active = False
    
    def connectionMade(self):
        if AudioWriter._started:
            logging.warning("Connection made after start")
            self.transport.loseConnection()
            return
        
        self._active = True
        AudioWriter._started = True
            
        self._audio_producer = AudioProducer(self._manager.mod_filename, self._write_samples)
        self.transport.registerProducer(self._audio_producer, True)
        self._audio_producer.resumeProducing()

    def connectionLost(self, reason):
        if self._active:
            self._manager.notify_done()
        
    def _write_samples(self, sample_buffer):
        if sample_buffer is AudioProducer.DONE:
            logging.info("Dropping connection")
            self.transport.unregisterProducer()
            self.transport.loseConnection()
        else:
            self.transport.write(sample_buffer)
        
        
class AudioWriterFactory(Factory):
    def __init__(self, manager):
        self._manager = manager
        
    def buildProtocol(self, addr):
        return AudioWriter(self._manager)


### Main ###

class Manager(object):
    def __init__(self, mod_filename):
        self.mod_filename = mod_filename
        
    def notify_done(self):
        self._producers -= 1
        if not self._producers:
            reactor.stop()
            
    def run(self):
        self._producers = 2
        
        vwf = VideoWriterFactory(self)
        video_port = reactor.listenTCP(0, vwf).getHost().port
        logging.info("Video server listening on port {}".format(video_port))

        awf = AudioWriterFactory(self)
        audio_port = reactor.listenTCP(0, awf).getHost().port
        logging.info("Audio server listening on port {}".format(audio_port))

        def start_ffmpeg():
            subprocess.Popen([FFMPEG, '-y',
                              '-f', 'rawvideo', '-pixel_format', 'bgra', '-video_size', '1920x1080', '-framerate', '60', '-i', 'tcp://127.0.0.1:{}'.format(video_port),
                              '-f', 's16le', '-ar', '48000', '-ac', '2', '-i', 'tcp://127.0.0.1:{}'.format(audio_port),
                              '-vsync', '2', '-crf', '15', '-vcodec', 'libx264', '-pix_fmt', 'yuv420p', '-preset', 'ultrafast', '-threads', '3', '-c:a', 'libvo_aacenc', '-b:a', '256k', '-movflags', 'faststart', 'out.mp4'])

        reactor.callWhenRunning(start_ffmpeg)
        reactor.run()
        
        

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)-7s %(message)s")
    Manager(sys.argv[1]).run()

    # with contextlib.closing(decode_mod.Module('4o.it')) as mod:

    #     with open('out.rawaudio', 'wb') as fout:
    #         while True:
    #             bf = mod.decode(1024)
    #             if bf is None:
    #                 break
    #             fout.write(''.join([struct.pack('<h', samp) for samp in bf]))

    #     import pdb; pdb.set_trace()


